<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>R 2019</title>
<meta name="author" content="(Luis G. Moyano)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="../../reveal.js/css/reveal.css"/>

<link rel="stylesheet" href="../../reveal.js/css/theme/my_beige.css" id="theme"/>

<link rel="stylesheet" href="../../reveal.js/lib/css/zenburn.css"/>
<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../../reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
<meta name="description" content="Programación en R 2017">
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h1>R 2019</h1><h3>03/04/2019</h3>
</section>

<section>
<section id="slide-org8e6f1b8">
<h2 id="org8e6f1b8">Repaso de la clase anterior</h2>
<div class="outline-text-2" id="text-org8e6f1b8">
</div>
</section>
</section>
<section>
<section id="slide-orgcfe0f9b">
<h3 id="orgcfe0f9b">'Types': tipos de datos</h3>
<ul>
<li><b>'logical'</b>:    TRUE o FALSE</li>
<li><b>'integer'</b>:    enteros: &#x2026;, -1, 0, 1, &#x2026;</li>
<li><b>'double'</b>:    irracionales: 3.1415926</li>
<li><b>'character'</b>:    alfanuméricos: "pi"</li>
<li><i>'complex':    1+i10</i></li>
<li><i>'raw':     48 65 6c 6c 6f</i></li>

</ul>

</section>
</section>
<section>
<section id="slide-org1729c4d">
<h3 id="org1729c4d">Objetos R: vectores</h3>
<p>
Existen dos clases de vectores:
</p>
<ol>
<li><span class="underline">Vectores 'atómicos'</span> (<i>atomic vectors</i>), todos los elementos del mismo tipo
<ul>
<li>puede haber de los 6 tipos: 'logical', 'integer', 'double', 'character', 'complex' y 'raw'</li>
<li>Integer y double son tratados como 'numeric'</li>
<li>No hay escalares en R, si no vectores de longitud 1</li>

</ul></li>

<li><span class="underline">Vectores recursivos - <i>Listas</i></span> :
<ul>
<li>Pueden a su vez contener listas  (por eso lo de recursivos)</li>
<li><i>data frames</i> son caso especial, cuando los vectores que la componen son de igual longitud</li>

</ul></li>

</ol>

<p>
La principal diferencia entre los vectores atómicos y las listas es que los primeros son homogéneos,
o sea todos sus elementos son del mismo tipo, mientras que en las listas no es necesario. 
</p>

</section>
</section>
<section>
<section id="slide-orgc95e16e">
<h3 id="orgc95e16e">Propiedades de los vectores</h3>
<p>
Las propiedades más importantes de los vectores son:
</p>

<ol>
<li>Que <i>tipo</i> de vector es. <code>typeof()</code></li>
<li>Que <i>longitud</i> tiene. <code>length()</code></li>
<li>Cuales <i>atributos</i> tiene asociados. <code>attributes()</code></li>

</ol>

<p>
Los atributos son metadata arbitraria que se puede asociar a cualquier objeto R. Se determinan y
consultan con <i>attr()</i> para alguno en particular y con <i>attributes()</i> se consultan todos los que el
objeto tenga. Los tres atributos más importantes se obtienen con <i>names()</i>, <i>class()</i> y <i>dim()</i>. 
</p>

</section>
</section>
<section>
<section id="slide-org615c060">
<h3 id="org615c060">Listas</h3>
<p>
Sus elementos pueden tener cualquier tipo, longitud (dimensión!) o atributos, incluyendo otras
listas o funciones ¯\_(ツ)_/¯
</p>

<div class="org-src-container">

<pre><code class="R" >x <- list(1, 2, 1:100)
x
## [[1]]
## [1] 1

## [[2]]
## [1] 2

## [[3]]
##  [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18
##  [19]  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36
##  [37]  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54
##  [55]  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72
##  [73]  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90
##  [91]  91  92  93  94  95  96  97  98  99 100

str(nasa)
## List of 2
##  $ mets:List of 7
##   ..$ cloudhigh  : num [1:24, 1:24, 1:12, 1:6] 26 20 16 13 7.5 8 14.5 19.5 22.5 21 ...
##   ..$ cloudlow   : num [1:24, 1:24, 1:12, 1:6] 7.5 11.5 16.5 20.5 26 30 29.5 26.5 27.5 26 ...
##   ..$ cloudmid   : num [1:24, 1:24, 1:12, 1:6] 34.5 32.5 26 14.5 10.5 9.5 11 17.5 18.5 16.5 ...
##   ..$ ozone      : num [1:24, 1:24, 1:12, 1:6] 304 304 298 276 274 264 258 252 250 250 ...
##   ..$ pressure   : num [1:24, 1:24, 1:12, 1:6] 835 940 960 990 1000 1000 1000 1000 1000 1000 ...
##   ..$ surftemp   : num [1:24, 1:24, 1:12, 1:6] 273 280 285 289 292 ...
##   ..$ temperature: num [1:24, 1:24, 1:12, 1:6] 272 282 285 291 293 ...
##  $ dims:List of 4
##   ..$ lat  : num [1:24] 36.2 33.7 31.2 28.7 26.2 ...
##   ..$ long : num [1:24] -114 -111 -109 -106 -104 ...
##   ..$ month: int [1:12] 1 2 3 4 5 6 7 8 9 10 ...
##   ..$ year : int [1:6] 1995 1996 1997 1998 1999 2000
##  - attr(*, "class")= chr "tbl_cube"
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-org9c1fbd3">
<h2 id="org9c1fbd3">Vectores "aumentados"</h2>
<ul>
<li><span class="underline">Data frames</span> (y <span class="underline">tibbles</span>) sobre 'lists'</li>
<li><span class="underline">Factores</span>, construidos sobre vectores 'integer'</li>
<li><span class="underline">Dates</span> y <span class="underline">date-times</span>, sobre vectores 'numeric'</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgb3c88eb">
<h3 id="orgb3c88eb">Data frames</h3>
<p>
Un data frame es una lista de vectores de igual longitud. Su estructura es 2d, con lo cual tiene
cosas en común con listas y con matrices. Se le pueden aplicar <code>names()</code>, <code>colnames()</code> y <code>rownames()</code>. 
</p>

<p>
Con <code>length()</code> obtenemos la longitud del data frame, y como es la cantidad de elementos de la lista, es igual a <code>ncol()</code>.
</p>

<div class="org-src-container">

<pre><code class="R" >df <- data.frame(x = 1:3, y = c("a", "b", "c"))
str(df)
identical(length(df), ncol(df))
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-orgefcd352">
<h3 id="orgefcd352">Factores</h3>
<p>
Los factores son vectores <b>no-atómicos</b> 'aumentados', usados para representar variables
categóricas (nominales). Estos datos pueden tomar sus valores de un conjunto fijo de elementos. Internamente son
representados por enteros, y R les asigna un atributo 'levels'.
</p>

<div class="org-src-container">

<pre><code class="R" >x <- factor(c("ab", "cd", "ab"), levels = c("ab", "cd", "ef"))
typeof(x)
#> [1] "integer"
attributes(x)
#> $levels
#> [1] "ab" "cd" "ef"
#> str(x)
#> Factor w/ 3 levels "ab","cd","ef": 1 2 1
#> $class
#> [1] "factor"
</code></pre>
</div>
</section>
</section>
<section>
<section id="slide-org27c3353">
<h3 id="org27c3353">Dates y date-times</h3>
<p>
Lo veremos más adelante.
</p>

</section>
</section>
<section>
<section id="slide-org8c82fac">
<h2 id="org8c82fac"><i>Subsetting</i></h2>
<p>
<i>Subsetting</i> se refiere a un conjunto de métodos para acceder a partes de objetos en R.
</p>

<p>
<code>[</code> es uno de los operadores más frecuentes para hacer <i>subsetting</i>. Si <code>x</code> es un vector atómico, <code>x[a]</code> es el elemento <code>a</code> del vector <code>x</code>. Hay distintas maneras de usar <code>[</code>.
</p>

</section>
</section>
<section>
<section id="slide-org9fb5a16">
<h3 id="org9fb5a16">Usando vectores de enteros positivos o negativos</h3>
<p>
Un vector numérico con enteros, todos positivos, todos negativos, o cero.
</p>
<div class="org-src-container">

<pre><code class="R" >x <- c("one", "two", "three", "four", "five")
x[c(3, 2, 5)]
#> [1] "three" "two"   "five"

x[c(1, 1, 5, 5, 5, 2)]
#> [1] "one"  "one"  "five" "five" "five" "two"

x[c(-1, -3, -5)]
#> [1] "two"  "four"

# caso particular, el cero, devuelve un vector vacio
x[0]
## numeric(0)
</code></pre>
</div>
</section>
</section>
<section>
<section id="slide-org65af1b3">
<h3 id="org65af1b3">Usando vectores de elementos lógicos</h3>
<p>
<i>Subsetting</i> con un vector lógico devuelve solo los valores de correspondientes a TRUE. Como <i>filter</i>, se
usa frecuentemente en conjunto con <i>expresiones lógicas</i>.
</p>
<div class="org-src-container">

<pre><code class="R" >x <- c(10, 3, NA, 5, 8, 1, NA)

# Todos los valores que no son NA de x
x[!is.na(x)]
#> [1] 10  3  5  8  1

# Todos los valores pares (o NAs!) de x
x[x %% 2 == 0]
#> [1] 10 NA  8 NA
</code></pre>
</div>
</section>
</section>
<section>
<section id="slide-orgbcb179c">
<h3 id="orgbcb179c">Usando vectores de caracteres para devolver elementos con nombres</h3>
<p>
Si tenemos un vector con sus elementos, o un data frame con sus columnas, con nombres, podemos acceder a los elementos así:
</p>
<div class="org-src-container">

<pre><code class="R" >x <- c(abc = 1, def = 2, xyz = 5)
x[c("xyz", "def")]
#> xyz def 
#>   5   2

mtcars[, c("mpg", "disp")] 
##                      mpg  disp
## Mazda RX4           21.0 160.0
## Mazda RX4 Wag       21.0 160.0
## Datsun 710          22.8 108.0
## ...
</code></pre>
</div>
</section>
</section>
<section>
<section id="slide-org24e871d">
<h3 id="org24e871d">No usando nada!</h3>
<p>
La manera más simple de hacer <i>subsetting</i> es no usando nada, <code>x[]</code>, que devuelve el objeto
original. Si es 2d, podemos dejar vacía una de las dimensiones, por ej. <code>x[1, ]</code> para obtener una fila (con todas sus columnas), o x[, -1] que selecciona todas las filas columnas menos la indicada.
</p>

<p>
Para el caso de data frames y matrices, al hacer subsetting es posible usar <code>drop = FALSE</code> para
preservar las dimensiones del objeto original.
</p>

</section>
</section>
<section>
<section id="slide-org33fd124">
<h3 id="org33fd124">Otros operadores de subsetting: <code>[[</code> y <code>$</code></h3>
<p>
Para listas, necesitamos <code>[[</code> para acceder al contenido de los elementos de la lista, <span class="underline">porque aplicando</span>
<code>[</code> <span class="underline">a una lista siempre devuelve otra lista</span> (más exactamente, una sub-lista). 
</p>

<p>
En cambio, <code>[[</code> saca un nivel de la jerarquía de la lista y puede devolver cualquier tipo de objeto, dependiendo del elemento
siendo accedido.
</p>

<p>
El operador <code>$</code> es una abreviación para obtener elementos <i>nombrados</i> de una lista. Se usa parecido a <code>[[</code>
solo que no hace falta usar las comillas.
</p>

<p>
Como los data frames son listas de columnas de igual longitud, podemos acceder a sus columnas usando
<code>mtcars[[1] ]</code>, <code>mtcars[["cy"] ]</code> o <code>mtcars$cy</code>. Estos dos últimos son equivalentes.
</p>


<aside class="notes">
<p>
Más sobre subsetting en los siguientes links:
<a href="http://adv-r.had.co.nz/Subsetting.html">http://adv-r.had.co.nz/Subsetting.html</a>
<a href="http://r4ds.had.co.nz/vectors.html#vector-subsetting">http://r4ds.had.co.nz/vectors.html#vector-subsetting</a>
</p>

</aside>
</section>
</section>
<section>
<section id="slide-org335ae0c">
<h3 id="org335ae0c">Diferencia entre [ y [[ para listas</h3>
<img style="WIDTH:500px; HEIGHT:420px; border:0" src="./figs/lists-subsetting.png">

</section>
</section>
<section>
<section id="slide-orga6ab54d">
<h3 id="orga6ab54d">Indexado de listas: '[[' vs. '['</h3>
<img style="border:0" src="./figs/pepper.png">

<p>
crédito - Hadley Wickham: <a href="http://t.co/YQ6axb2w7t">http://t.co/YQ6axb2w7t</a>
</p>
</section>
</section>
<section>
<section id="slide-org6d4dfd5">
<h2 id="org6d4dfd5">Práctica 6</h2>
<p>
Descargar <a href="./../assets/R2019-practice-6-x84tml1b0c.pdf">práctica 6</a>.
</p>
</section>
</section>
</div>
</div>
<p> @luisgmoyano </p>
<script src="../../reveal.js/lib/js/head.min.js"></script>
<script src="../../reveal.js/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: 'c',
rollingLinks: false,
keyboard: true,
overview: true,
margin: 0.10,
minScale: 0.50,
maxScale: 2.50,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'slide', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'fast',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: '../../reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }]
});
</script>
</body>
</html>
