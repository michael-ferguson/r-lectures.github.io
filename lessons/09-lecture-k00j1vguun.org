#    -*- mode: org -*-
#+TITLE: R lectures
#+DATE: 09/05/2017
#+AUTHOR: Luis G. Moyano
#+EMAIL: lgmoyano@gmail.com

#+OPTIONS: author:nil date:t email:nil
#+OPTIONS: ^:nil _:nil
#+STARTUP: showall expand
#+options: toc:nil
#+REVEAL_ROOT: ../../reveal.js/
#+REVEAL_TITLE_SLIDE_TEMPLATE: Recursive Search
#+OPTIONS: reveal_center:t reveal_progress:t reveal_history:nil reveal_control:t 
#+OPTIONS: reveal_rolling_links:nil reveal_keyboard:t reveal_overview:t num:nil
#+OPTIONS: reveal_title_slide:"<h1>%t</h1><h3>%d</h3>"
#+REVEAL_MARGIN: 0.1
#+REVEAL_MIN_SCALE: 0.5
#+REVEAL_MAX_SCALE: 2.5
#+REVEAL_TRANS: slide
#+REVEAL_SPEED: fast
#+REVEAL_THEME: my_moon
#+REVEAL_HEAD_PREAMBLE: <meta name="description" content="Programación en R 2017">
#+REVEAL_POSTAMBLE: <p> @luisgmoyano </p>
#+REVEAL_PLUGINS: (highlight)
#+REVEAL_HIGHLIGHT_CSS: %r/lib/css/zenburn.css
#+REVEAL_HLEVEL: 1

# # (setq org-reveal-title-slide "<h1>%t</h1><br/><h2>%a</h2><h3>%e / <a href=\"http://twitter.com/ben_deane\">@ben_deane</a></h3><h2>%d</h2>")
# # (setq org-reveal-title-slide 'auto)
# # see https://github.com/yjwen/org-reveal/commit/84a445ce48e996182fde6909558824e154b76985

# #+OPTIONS: reveal_width:1200 reveal_height:800
# #+OPTIONS: toc:1
# #+REVEAL_PLUGINS: (markdown notes)
# #+REVEAL_EXTRA_CSS: ./local
# ## black, blood, league, moon, night, serif, simple, sky, solarized, source, template, white
# #+REVEAL_HEADER: <meta name="description" content="Programación en R 2017">
# #+REVEAL_FOOTER: <meta name="description" content="Programación en R 2017">


#+begin_src yaml :exports (when (eq org-export-current-backend 'md) "results") :exports (when (eq org-export-current-backend 'reveal) "none") :results value html 
--- 
layout: default 
title: Clase 9
--- 
#+end_src 
#+results:

# #+begin_html
# <img src="right-fail.png">
# #+end_html

# #+ATTR_REVEAL: :frag roll-in

* Repaso de la clase anterior
** Operadores lógicos
Son operadores que permiten comparar dos enunciados y evaluan a resultado lógico. 

        - ~>~ , ~>=~
        - ~<~ , ~<=~
        - ~!=~ , ~==~ 

Más los operadores && (AND) y || (OR) para elaborar enunciados más complejos

Combinando operadores construimos expresiones condicionales, que R evalua a TRUE o FALSE (o NA).

** Ejecución condicional

#+BEGIN_SRC R 
if (condición) {
  # código que se ejecuta cuando la condición evalua a TRUE
} else {
  # código que se ejecuta cuando la condición evalua a FALSE
}
#+END_SRC

Nota: Si el cuerpo del ~if()~ tiene una sola línea, podemos obviar los {}

#+BEGIN_SRC R 
if (this) {
  # do that
} else if (that) {
  # do something else
} else {
  # 
}
#+END_SRC

** funciones lógicas accesorias

        - ~any()~         # devuelve ~TRUE~ si alguno ~TRUE~
        - ~all()~         # devuelve ~FALSE~ si alguno ~FALSE~
        - ~is.na()~, ~is.null()~ y el resto de la familia ~is./algo/()~
        - ~%in%~          # está ~x~ en este vector?`
        - ~which()~       # devuelve posiciones de elementos ~TRUE~
        - ~identical()~   # por ej., numeric vs. integer
        - muchas otras

** Componentes de un for
Loops son bucles y se usan para repetir código
- Output: siempre es buena idea crear el objeto antes de calcularlo
- Secuencia: variable sobre la que funciona el bucle
 #+BEGIN_SRC R 
 for (x in xs)
 for(i in seq_along(df))
 for (nm in names(xs))
 #+END_SRC
- Cuerpo: código que se ejecuta las veces que la secuencia indique

~while()~ es un loop controlado por una expresión condicional

Nota: Si el cuerpo de ~for()~ o del ~while()~ tienen una sola línea, podemos obviar las {}
* Subsetting con la función ~subset()~
~?subset()~
/Return subsets of vectors, matrices or data frames which meet conditions./

#+BEGIN_SRC R 
 subset(airquality, Temp > 80, select = c(Ozone, Temp))
 subset(airquality, Day == 1, select = -Temp)
 subset(airquality, select = Ozone:Wind)
#+END_SRC

* Vectorización
Se trata de operaciones que aplican a un vector, pero elemento por elemento. 

1. Los pasos se simplifican al no pensar en los elementos del vector, si no en el vector en sí.
2. Los bucles en una función vectorizada están hechos en C y no en R, y por lo tanto son mucho más
   rápidos.

#+BEGIN_SRC R 
# sin vectorización
for (i in 1:length(x)) z[i] <- x[i] + y[i]

# con vectorización
z <- x + y
#+END_SRC

- Ref: [[http://adv-r.had.co.nz/Profiling.html#vectorise][Vectorise from Advanced R]]
** Operadores y funciones vectorizados
1) ~==~, ~&~, y ~|~
2) corchetito: Por ej, ~x[is.na(x)] <- 0~ donde ~x~ es vector, matriz o dataframe
3) otras funciones: ~+~, ~-~, ~*~, ~cumsum()~, ~diff()~, ~rowSums()~, ~colSums()~, ~rowMeans()~, ~colMeans()~, etc.
4) ~any(x == 10)~ es mucho más rápido que ~10 %in% x~.

#+BEGIN_SRC R 
c(T,T,F,F) == c(T,F,T,F)
[1]  TRUE FALSE FALSE  TRUE
c(T,T,F,F) & c(T,F,T,F)
[1]  TRUE FALSE FALSE FALSE
c(T,T,F,F) | c(T,F,T,F)
[1]  TRUE  TRUE  TRUE FALSE
#+END_SRC
** operadores lógicos simples o dobles
- Los operadores simples  ~&~ (AND) y ~|~ (OR) son vectorizados
- Los operadores dobles ~&&~ (AND) y ~||~ (OR) evalúan de izquierda a derecha solo el primer
  elemento. Se procede hasta que el resultado se alcanza.

#+BEGIN_SRC R
NA & T
[1] NA
NA & F
[1] FALSE
c(NA, T) && c(T, T)
[1] NA
c(NA, T) && c(F, T)
[1] FALSE
c(NA, T) & c(T, T)
[1]   NA TRUE
c(NA, T) & c(F, T)
[1] FALSE  TRUE
#+END_SRC

** Eficiencia
#+BEGIN_SRC R 
x <- runif(1000000)
y <- runif(1000000)
z <- vector(length=1000000)

system.time(z <- x + y)
  user  system elapsed
  0.052   0.016   0.068

system.time(for (i in 1:length(x)) z[i] <- x[i] + y[i])
 user  system elapsed
 8.088   0.044   8.175
#+END_SRC
* Funcionales - Familia *apply()
~lapply()~, ~sapply()~, ~apply()~ y ~tapply()~ (hay más...)

Combinan algo similar a vectorización con funciones. Suelen ser la respuesta a "cómo hago para
procesar (por ejemplo transformar o extraer información de) cada elemento de este objeto?"

Hemos hecho cosas similares con ~summarise()~ + ~group_by()~ y ~mutate()~.

Ref: ver también el [[https://www.rdocumentation.org/packages/plyr/versions/1.8.4][paquete plyr]], [[http://stat545.com/block013_plyr-ddply.html][esta web]] y [[http://www.jstatsoft.org/v40/i01/][este paper]]
** ~lapply()~
LLama a una función especificada en cada componente de una lista y devuelve otra lista

#+BEGIN_EXPORT html
<img style="WIDTH:400px; HEIGHT:300px; border:0" src="./figs/lapply.png">
#+END_EXPORT

#+BEGIN_SRC R 
  lapply(list(1:3,25:29), median)
  [[1]]
  [1] 2
  [[2]] 
  [1] 27
#+END_SRC

#+RESULTS:

** ~sapply()~
En _algunos_ casos, la lista que devuelve lapply() puede ser simplificada a un vector o a una
matriz. Esto es justo lo que hace sapply().
#+BEGIN_EXPORT html
<img style="WIDTH:400px; HEIGHT:300px; border:0" src="./figs/sapply.png">
#+END_EXPORT

#+BEGIN_SRC R 
sapply(list(1:3,25:29),median)
[1]  2 27
#+END_SRC
** ~lapply()~ y ~sapply()~ en data frames
Tanto ~lapply~ como ~sapply~ están pensados para listas, por lo tanto funcionan bien en data.frames

#+BEGIN_SRC R 
lapply(economics, mean)
$date
[1] "1991-05-17"

$pce
[1] 4843.51

$pop
[1] 257189.4

$psavert
[1] 7.936585

$uempmed
[1] 8.610105

$unemploy
[1] 7771.557

sapply(economics, mean)
        date          pce          pop      psavert      uempmed     unemploy 
7.806399e+03 4.843510e+03 2.571894e+05 7.936585e+00 8.610105e+00 7.771557e+03 
#+END_SRC
** ~apply()~
~apply()~ es para matrices. Tienen la particularidad que podemos elegir aplicar una función a filas o a
columnas.

~apply(m,dimcode,f,fargs)~
- m: matriz
- dimcode: 1 o 2, 1 se aplicamos a filas, 2 a columnas
- f: función que vamos a aplicar
- fargs: argumentos adicionales

#+BEGIN_SRC R 
  z
  [,1] [,2]
  [1,]    1    4
  [2,]    2    5
  [3,]    3    6

  apply(z,2,mean)
  [1] 2 5
#+END_SRC
** ~apply()~ - un ejemplo con función propia
#+BEGIN_SRC R 
z
[,1] [,2]
[1,]    1    4
[2,]    2    5
[3,]    3    6
f <- function(x) x/c(2,8)
y <- apply(z,1,f)
y
[,1] [,2] [,3]
[1,]  0.5 1.000 1.50
[2,]  0.5 0.625 0.75
#+END_SRC
** ~tapply()~
para aplicar funciones a vectores con factores

#+BEGIN_SRC R 
ages <- c(25,26,55,37,21,42)
affils <- c("R","D","D","R","U","D")
tapply(ages,affils,mean)
D   R   U 
41  31  21
#+END_SRC

#+BEGIN_SRC R 
d <- data.frame(list(gender=c("M","M","F","M","F","F"),
+ age=c(47,59,21,32,33,24),income=c(55000,88000,32450,76500,123000,45650))) 
d
  gender age income
1 M      47  55000
2 M      5 9 88000
...
d$over25 <- ifelse(d$age > 25,1,0) 
d
  gender age income over25
1 M      47  55000  1
2 M      59  88000  1
...
tapply(d$income,list(d$gender,d$over25),mean)
0       1 
F 39050 123000.00 
M NA    73166.67
#+END_SRC
* Práctica 9

1. Como se comparan los resultados de ~mean()~ y ~mean.default()~ con 10000 observaciones, en vez de con
   100? Usar ~system.time()~.
2. Comparar la velocidad de ~apply(x, 1, sum)~ con ~rowSums(x)~ para ~x~ de distintos tamaños. Usar ~system.time()~.
3. El código a continuación simula el desempeño de un t-test para datos no normales. Usen ~sapply()~ y
   una función (puede ser anónima, es decir no necesitan nombrarla) para extraer el p-value de cada
   'tirada'. Nota: ~rpois()~ nos devuelve una 'tirada' de variable aleatoria (como si fuera tirar una
   moneda) de una distribución de Poisson.
  #+BEGIN_SRC R 
  trials <- replicate(
    100, 
    t.test(rpois(10, 10), rpois(7, 10)),
    simplify = FALSE
  )
  #+END_SRC 
